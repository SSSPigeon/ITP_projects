/-(An Incomplete) Formalisation of the four square theorem-/
/-Based on :
chrome-extension://efaidnbmnnnibpcajpcglclefindmkaj/https://www.math.uchicago.edu/~may/VIGRE/VIGRE2008/REUPapers/Ng.pdf-/
/-Main results: theorem FourSquareIdentity, theorem half_or, theorem normSq_int, theorem Hurtint_unit_of_int_unit-/



import Mathlib.Algebra.Quaternion
import Mathlib.Algebra.Star.Basic
import Mathlib.Algebra.Group.Units
import Mathlib.Data.Complex.Basic
import Mathlib.Data.Int.Order.Units
import Mathlib.Init.Logic
import Mathlib.Tactic

open Quaternion
open QuaternionAlgebra

set_option maxHeartbeats 20000000

/-Definition 1.1-/
#check Quaternion
def l1 : Quaternion ℤ :=
{re := 1, imI := 0, imJ := 0, imK :=0}

def li : Quaternion ℤ :=
{re := 0, imI := 1, imJ := 0, imK :=0}

def lj : Quaternion ℤ :=
{re := 0, imI := 0, imJ := 1, imK :=0}

def lk : Quaternion ℤ :=
{re := 0, imI := 0, imJ := 0, imK := 1}


#check normSq

/-- Some properties of the norms of quaternions l1, li, lj, lk mentioned after Definition 1.2.
  They don't play any roles in the subsequent proofs in this file.-/
example: normSq l1 = 1 := by
    rw [normSq_def' l1]
    simp[l1]

example: normSq li = 1 := by
    rw [normSq_def' li]
    simp[li]

example: normSq lj = 1 := by
    rw [normSq_def' lj]
    simp[lj]

example: normSq lk = 1 := by
    rw [normSq_def' lk]
    simp[lk]

example: li * li = -1 := by
    simp only[li]
    aesop

example: lj * lj = -1 := by
    simp only[lj]
    aesop

example: lk * lk = -1 := by
    simp only[lk]
    aesop

example: li * lj = lk := by
    simp[li, lj, lk]
    aesop

example: - lj * li = lk := by
    simp[li, lj, lk]
    aesop

example: lj * lk = li := by
    simp[li, lj, lk]
    aesop

example: - lk * lj = li := by
    simp[li, lj, lk]
    aesop

example: lk * li = lj := by
    simp[li, lj, lk]
    aesop

example: - li * lk = lj := by
    simp[li, lj, lk]
    aesop



/-- Theorem 1.3 Four Square Identity: If two numbers can each be written as the sum of four squares, then so can their product.-/
theorem FourSquareIdentity (a₁ a₂ b₁ b₂ c₁ c₂ d₁ d₂ x₁ x₂: ℤ) :
x₁ = a₁^2 + b₁^2 + c₁^2 + d₁^2 ∧ x₂ = a₂^2 + b₂^2 + c₂^2 + d₂^2 →
∃ a₃ b₃ c₃ d₃ : ℤ , x₁ * x₂ = a₃^2 + b₃^2 + c₃^2 + d₃^2 := by
    intro ⟨h1, h2⟩
    let q₁ := (a₁•l1 + b₁•li + c₁•lj + d₁•lk)
    let q₂ := (a₂•l1 + b₂•li + c₂•lj + d₂•lk)
    have g1: x₁ = normSq q₁ := by
        simp only [q₁, l1, li, lj, lk]
        rw [smul_mk a₁, smul_mk b₁, smul_mk c₁, smul_mk d₁]
        simp[mk_add_mk, normSq, h1]; ring
    have g2: x₂ = normSq q₂ := by
        simp only [q₂, l1, li, lj, lk]
        rw [smul_mk a₂, smul_mk b₂, smul_mk c₂, smul_mk d₂]
        simp[mk_add_mk, normSq, h2]
        ring
    use (q₁*q₂).re; use (q₁*q₂).imI; use (q₁*q₂).imJ; use (q₁*q₂).imK
    rw[g1, g2, ← normSq_def']
    exact Eq.symm (MonoidWithZeroHom.map_mul normSq q₁ q₂)


/-- Define the Hurwitz integers as the subring of `Quaternion ℚ`
generated by the set `{i, j, k, l}`. -/
def i : Quaternion ℚ :=
  ⟨0, 1, 0, 0⟩

def j : Quaternion ℚ :=
  ⟨0, 0, 1, 0⟩

def k : Quaternion ℚ :=
  ⟨0, 0, 0, 1⟩

def l : Quaternion ℚ :=
  ⟨1/2, 1/2, 1/2, 1/2⟩


def HurInt : Subring (Quaternion ℚ) :=
  Subring.closure {i, j, k, l}


/-- This theorem shows that our definition of Hurwitz integers is equivalent to another
  definition, see https://en.wikipedia.org/wiki/Hurwitz_quaternion.
  Also, it is very important in the proofs of subsequent theorems.-/
theorem half_or : ∀ γ : HurInt, ∃ (a b c d : ℤ),
      γ.val = ⟨a, b, c, d⟩ ∨
      γ.val = ⟨a+1/2,b+1/2,c+1/2,d+1/2⟩ := by
  intro ⟨γ, γmem⟩
  apply Subring.closure_induction (h := γmem)
    (p := fun γ => ∃ (a b c d : ℤ), γ = ⟨a,b,c,d⟩ ∨ γ = ⟨a+1/2,b+1/2,c+1/2,d+1/2⟩)
  . intro hx xmem
    rcases xmem with hi | hj | hk | hl
    . use 0, 1, 0, 0; left; rw[hi]; rfl
    . use 0, 0, 1, 0; left; rw[hj]; rfl
    . use 0, 0, 0, 1; left; rw[hk]; rfl
    . use 1/2, 1/2, 1/2, 1/2; right; rw[hl]; rfl
  . use 0, 0, 0, 0; left; rfl
  . use 1, 0, 0, 0; left; rfl
  . intro x y hx hy
    rcases hx with ⟨xa, xb, xc, xd, hx'⟩
    rcases hy with ⟨ya, yb, yc, yd, hy'⟩
    rcases hx' with hx1 | hx2
    rcases hy' with hy1 | hy2
    . use xa+ya, xb+yb, xc+yc, xd+yd; left; rw[hx1,hy1]
      simp; apply mk_add_mk
    . use xa+ya, xb+yb, xc+yc, xd+yd; right; rw[hx1,hy2]
      simp; rw[mk_add_mk]; ring_nf
    rcases hy' with hy1 | hy2
    . use xa+ya, xb+yb, xc+yc, xd+yd; right; rw[hx2,hy1]
      simp; rw[mk_add_mk]; ring_nf
    . use xa+ya+1, xb+yb+1, xc+yc+1, xd+yd+1; left; rw[hx2,hy2]
      simp; rw[mk_add_mk]; ring_nf
  . intro x hx
    rcases hx with ⟨xa, xb, xc, xd, h1 | h2⟩
    . use -xa, -xb, -xc, -xd; left; rw[h1]
      simp; rfl
    . use -xa-1, -xb-1, -xc-1, -xd-1; right; rw[h2]
      -- ext, or equivalently
      apply Quaternion.ext <;> { simp; ring }
  . intro x y hx hy
    rcases hx with ⟨xa, xb, xc, xd, hx'⟩
    rcases hy with ⟨ya, yb, yc, yd, hy'⟩
    rcases hx' with hx1 | hx2
    rcases hy' with hy1 | hy2
    . use xa*ya-xb*yb-xc*yc-xd*yd;
      use xa*yb+xb*ya+xc*yd-xd*yc;
      use xa*yc-xb*yd+xc*ya+xd*yb;
      use xa*yd+xb*yc-xc*yb+xd*ya;
      rw[hx1, hy1]; left; ext <;> simp
    . rcases Int.even_or_odd (xa-xb-xc-xd) with ⟨k1,hk1⟩ | ⟨k1,hk1⟩
      . use xa*ya-xb*yb-xc*yc-xd*yd+k1
        have ⟨k2, hk2⟩ :∃k:ℤ, xa+xb+xc-xd = k+k := by use k1+xb+xc; linarith
        use xa*yb+xb*ya+xc*yd-xd*yc+k2
        have ⟨k3, hk3⟩ :∃k:ℤ, xa-xb+xc+xd = k+k := by use k1+xc+xd; linarith
        use xa*yc-xb*yd+xc*ya+xd*yb+k3
        have ⟨k4, hk4⟩ :∃k:ℤ, xa+xb-xc+xd = k+k := by use k1+xb+xd; linarith
        use xa*yd+xb*yc-xc*yb+xd*ya+k4
        rw[hx1, hy2]; left; ext
        . simp[Quaternion.mul_re]
          have h': (2:ℚ) * ↑k1 = ↑xa - ↑xb - ↑xc - ↑xd := by
            calc (2:ℚ) * ↑k1 = ↑k1 + ↑k1 := by linarith
                    _  = ↑(k1 + k1) := by simp
                    _  = ↑(xa - xb - xc - xd) := by rw[hk1]
                    _  = ↑xa - ↑xb - ↑xc - ↑xd := by simp
          have ne0: (2:ℚ) ≠ 0 := by norm_num
          have : ↑k1 = (2:ℚ)⁻¹ * (↑xa - ↑xb - ↑xc - ↑xd) :=
            (eq_inv_mul_iff_mul_eq₀ ne0).mpr h'
          rw[this]; ring
        . simp[Quaternion.mul_imI]
          have h': (2:ℚ) * ↑k2 = ↑xa + ↑xb + ↑xc - ↑xd := by
            calc (2:ℚ) * ↑k2 = ↑k2 + ↑k2 := by linarith
                    _  = ↑(k2 + k2) := by simp
                    _  = ↑(xa + xb + xc - xd) := by rw[← hk2]
                    _  = ↑xa + ↑xb + ↑xc - ↑xd := by simp
          have ne0: (2:ℚ) ≠ 0 := by norm_num
          have : ↑k2 = (2:ℚ)⁻¹ * (↑xa + ↑xb + ↑xc - ↑xd) :=
            (eq_inv_mul_iff_mul_eq₀ ne0).mpr h'
          rw[this]; ring
        . simp[Quaternion.mul_imJ]
          have h': (2:ℚ) * ↑k3 = ↑xa - ↑xb + ↑xc + ↑xd := by
            calc (2:ℚ) * ↑k3 = ↑k3 + ↑k3 := by linarith
                    _  = ↑(k3 + k3) := by simp
                    _  = ↑(xa - xb + xc + xd) := by rw[← hk3]
                    _  = ↑xa - ↑xb + ↑xc + ↑xd := by simp
          have ne0: (2:ℚ) ≠ 0 := by norm_num
          have : ↑k3 = (2:ℚ)⁻¹ * (↑xa - ↑xb + ↑xc + ↑xd) :=
            (eq_inv_mul_iff_mul_eq₀ ne0).mpr h'
          rw[this]; ring
        . simp[Quaternion.mul_imK]
          have h': (2:ℚ) * ↑k4 = ↑xa + ↑xb - ↑xc + ↑xd := by
            calc (2:ℚ) * ↑k4 = ↑k4 + ↑k4 := by linarith
                    _  = ↑(k4 + k4) := by simp
                    _  = ↑(xa + xb - xc + xd) := by rw[← hk4]
                    _  = ↑xa + ↑xb - ↑xc + ↑xd := by simp
          have ne0: (2:ℚ) ≠ 0 := by norm_num
          have : ↑k4 = (2:ℚ)⁻¹ * (↑xa + ↑xb - ↑xc + ↑xd) :=
            (eq_inv_mul_iff_mul_eq₀ ne0).mpr h'
          rw[this]; ring
      . use xa*ya-xb*yb-xc*yc-xd*yd+k1
        have ⟨k2, hk2⟩ :∃k:ℤ, xa+xb+xc-xd = 2*k+1 := by use k1+xb+xc; linarith
        use xa*yb+xb*ya+xc*yd-xd*yc+k2
        have ⟨k3, hk3⟩ :∃k:ℤ, xa-xb+xc+xd = 2*k+1 := by use k1+xc+xd; linarith
        use xa*yc-xb*yd+xc*ya+xd*yb+k3
        have ⟨k4, hk4⟩ :∃k:ℤ, xa+xb-xc+xd = 2*k+1 := by use k1+xb+xd; linarith
        use xa*yd+xb*yc-xc*yb+xd*ya+k4
        rw[hx1, hy2]; right; ext
        . simp[Quaternion.mul_re]
          have h': (2:ℚ) * (↑k1 + (2:ℚ)⁻¹) = ↑xa - ↑xb - ↑xc - ↑xd := by
            calc (2:ℚ) * (↑k1 + (2:ℚ)⁻¹) = (2:ℚ) * ↑k1 + (1:ℚ) := by ring
              _ = ↑(xa - xb - xc - xd) := by simp[hk1]
              _ = ↑xa - ↑xb - ↑xc - ↑xd := by simp
          have ne0: (2:ℚ) ≠ 0 := by norm_num
          have : ↑k1 + (2:ℚ)⁻¹ = (2:ℚ)⁻¹ * (↑xa - ↑xb - ↑xc - ↑xd) :=
            (eq_inv_mul_iff_mul_eq₀ ne0).mpr h'
          have : ↑k1  = (2:ℚ)⁻¹ * (↑xa - ↑xb - ↑xc - ↑xd) - (2:ℚ)⁻¹ :=
            by linarith
          simp[this]; ring
        . simp[Quaternion.mul_imI]
          have h': (2:ℚ) * (↑k2 + (2:ℚ)⁻¹) = ↑xa + ↑xb + ↑xc - ↑xd := by
            calc (2:ℚ) * (↑k2 + (2:ℚ)⁻¹) = (2:ℚ) * ↑k2 + (1:ℚ) := by ring
              _ = ↑(xa + xb + xc - xd) := by simp[hk2]
              _ = ↑xa + ↑xb + ↑xc - ↑xd := by simp
          have ne0: (2:ℚ) ≠ 0 := by norm_num
          have : ↑k2 + (2:ℚ)⁻¹ = (2:ℚ)⁻¹ * (↑xa + ↑xb + ↑xc - ↑xd) :=
            (eq_inv_mul_iff_mul_eq₀ ne0).mpr h'
          have : ↑k2  = (2:ℚ)⁻¹ * (↑xa + ↑xb + ↑xc - ↑xd) - (2:ℚ)⁻¹ :=
            by linarith
          simp[this]; ring
        . simp[Quaternion.mul_imJ]
          have h': (2:ℚ) * (↑k3 + (2:ℚ)⁻¹) = ↑xa - ↑xb + ↑xc + ↑xd := by
            calc (2:ℚ) * (↑k3 + (2:ℚ)⁻¹) = (2:ℚ) * ↑k3 + (1:ℚ) := by ring
              _ = ↑(xa - xb + xc + xd) := by simp[hk3]
              _ = ↑xa - ↑xb + ↑xc + ↑xd := by simp
          have ne0: (2:ℚ) ≠ 0 := by norm_num
          have : ↑k3 + (2:ℚ)⁻¹ = (2:ℚ)⁻¹ * (↑xa - ↑xb + ↑xc + ↑xd) :=
            (eq_inv_mul_iff_mul_eq₀ ne0).mpr h'
          have : ↑k3  = (2:ℚ)⁻¹ * (↑xa - ↑xb + ↑xc + ↑xd) - (2:ℚ)⁻¹ :=
            by linarith
          simp[this]; ring
        . simp[Quaternion.mul_imJ]
          have h': (2:ℚ) * (↑k4 + (2:ℚ)⁻¹) = ↑xa + ↑xb - ↑xc + ↑xd := by
            calc (2:ℚ) * (↑k4 + (2:ℚ)⁻¹) = (2:ℚ) * ↑k4 + (1:ℚ) := by ring
              _ = ↑(xa + xb - xc + xd) := by simp[hk4]
              _ = ↑xa + ↑xb - ↑xc + ↑xd := by simp
          have ne0: (2:ℚ) ≠ 0 := by norm_num
          have : ↑k4 + (2:ℚ)⁻¹ = (2:ℚ)⁻¹ * (↑xa + ↑xb - ↑xc + ↑xd) :=
            (eq_inv_mul_iff_mul_eq₀ ne0).mpr h'
          have : ↑k4  = (2:ℚ)⁻¹ * (↑xa + ↑xb - ↑xc + ↑xd) - (2:ℚ)⁻¹ :=
            by linarith
          simp[this]; ring
    rcases hy' with hy1 | hy2
    . rcases Int.even_or_odd (ya-yb-yc-yd) with ⟨k1,hk1⟩ | ⟨k1,hk1⟩
      . use xa*ya-xb*yb-xc*yc-xd*yd+k1
        have ⟨k2, hk2⟩ :∃k:ℤ, ya+yb-yc+yd = k+k := by use k1+yb+yd; linarith
        use xa*yb+xb*ya+xc*yd-xd*yc+k2
        have ⟨k3, hk3⟩ :∃k:ℤ, ya+yb+yc-yd = k+k := by use k1+yb+yc; linarith
        use xa*yc-xb*yd+xc*ya+xd*yb+k3
        have ⟨k4, hk4⟩ :∃k:ℤ, ya-yb+yc+yd = k+k := by use k1+yc+yd; linarith
        use xa*yd+xb*yc-xc*yb+xd*ya+k4
        rw[hx2, hy1]; left; ext
        . simp[Quaternion.mul_re]
          have h': (2:ℚ) * ↑k1 = ↑ya - ↑yb - ↑yc - ↑yd := by
            calc (2:ℚ) * ↑k1 = ↑k1 + ↑k1 := by linarith
                    _  = ↑(k1 + k1) := by simp
                    _  = ↑(ya - yb - yc - yd) := by rw[hk1]
                    _  = ↑ya - ↑yb - ↑yc - ↑yd := by simp
          have ne0: (2:ℚ) ≠ 0 := by norm_num
          have : ↑k1 = (2:ℚ)⁻¹ * (↑ya - ↑yb - ↑yc - ↑yd) :=
            (eq_inv_mul_iff_mul_eq₀ ne0).mpr h'
          rw[this]; ring
        . simp[Quaternion.mul_imI]
          have h': (2:ℚ) * ↑k2 = ↑ya + ↑yb - ↑yc + ↑yd := by
            calc (2:ℚ) * ↑k2 = ↑k2 + ↑k2 := by linarith
                    _  = ↑(k2 + k2) := by simp
                    _  = ↑(ya + yb - yc + yd) := by rw[← hk2]
                    _  = ↑ya + ↑yb - ↑yc + ↑yd := by simp
          have ne0: (2:ℚ) ≠ 0 := by norm_num
          have : ↑k2 = (2:ℚ)⁻¹ * (↑ya + ↑yb - ↑yc + ↑yd) :=
            (eq_inv_mul_iff_mul_eq₀ ne0).mpr h'
          rw[this]; ring
        . simp[Quaternion.mul_imJ]
          have h': (2:ℚ) * ↑k3 = ↑ya + ↑yb + ↑yc - ↑yd := by
            calc (2:ℚ) * ↑k3 = ↑k3 + ↑k3 := by linarith
                    _  = ↑(k3 + k3) := by simp
                    _  = ↑(ya + yb + yc - yd) := by rw[← hk3]
                    _  = ↑ya + ↑yb + ↑yc - ↑yd := by simp
          have ne0: (2:ℚ) ≠ 0 := by norm_num
          have : ↑k3 = (2:ℚ)⁻¹ * (↑ya + ↑yb + ↑yc - ↑yd) :=
            (eq_inv_mul_iff_mul_eq₀ ne0).mpr h'
          rw[this]; ring
        . simp[Quaternion.mul_imK]
          have h': (2:ℚ) * ↑k4 = ↑ya - ↑yb + ↑yc + ↑yd := by
            calc (2:ℚ) * ↑k4 = ↑k4 + ↑k4 := by linarith
                    _  = ↑(k4 + k4) := by simp
                    _  = ↑(ya - yb + yc + yd) := by rw[← hk4]
                    _  = ↑ya - ↑yb + ↑yc + ↑yd := by simp
          have ne0: (2:ℚ) ≠ 0 := by norm_num
          have : ↑k4 = (2:ℚ)⁻¹ * (↑ya - ↑yb + ↑yc + ↑yd) :=
            (eq_inv_mul_iff_mul_eq₀ ne0).mpr h'
          rw[this]; ring
      . use xa*ya-xb*yb-xc*yc-xd*yd+k1
        have ⟨k2, hk2⟩ :∃k:ℤ, ya+yb-yc+yd = 2*k+1 := by use k1+yb+yd; linarith
        use xa*yb+xb*ya+xc*yd-xd*yc+k2
        have ⟨k3, hk3⟩ :∃k:ℤ, ya+yb+yc-yd = 2*k+1 := by use k1+yb+yc; linarith
        use xa*yc-xb*yd+xc*ya+xd*yb+k3
        have ⟨k4, hk4⟩ :∃k:ℤ, ya-yb+yc+yd = 2*k+1 := by use k1+yc+yd; linarith
        use xa*yd+xb*yc-xc*yb+xd*ya+k4
        rw[hx2, hy1]; right; ext
        . simp[Quaternion.mul_re]
          have h': (2:ℚ) * (↑k1 + (2:ℚ)⁻¹) = ↑ya - ↑yb - ↑yc - ↑yd := by
            calc (2:ℚ) * (↑k1 + (2:ℚ)⁻¹) =  (2:ℚ) * ↑k1 + (1:ℚ) := by ring
                    _  = ↑(ya - yb - yc - yd) := by simp[hk1]
                    _  = ↑ya - ↑yb - ↑yc - ↑yd := by simp
          have ne0: (2:ℚ) ≠ 0 := by norm_num
          have : ↑k1 + (2:ℚ)⁻¹ = (2:ℚ)⁻¹ * (↑ya - ↑yb - ↑yc - ↑yd) :=
            (eq_inv_mul_iff_mul_eq₀ ne0).mpr h'
          have : ↑k1 = (2:ℚ)⁻¹ * (↑ya - ↑yb - ↑yc - ↑yd) - (2:ℚ)⁻¹ :=
            by linarith
          rw[this]; ring
        . simp[Quaternion.mul_imI]
          have h': (2:ℚ) * (↑k2 + (2:ℚ)⁻¹)  = ↑ya + ↑yb - ↑yc + ↑yd := by
            calc (2:ℚ) * (↑k2 + (2:ℚ)⁻¹) = (2:ℚ) * ↑k2 + (1:ℚ) := by ring
                    _  = ↑(ya + yb - yc + yd) := by simp[hk2]
                    _  = ↑ya + ↑yb - ↑yc + ↑yd := by simp
          have ne0: (2:ℚ) ≠ 0 := by norm_num
          have : ↑k2 + (2:ℚ)⁻¹ = (2:ℚ)⁻¹ * (↑ya + ↑yb - ↑yc + ↑yd) :=
            (eq_inv_mul_iff_mul_eq₀ ne0).mpr h'
          have : ↑k2  = (2:ℚ)⁻¹ * (↑ya + ↑yb - ↑yc + ↑yd) - (2:ℚ)⁻¹:=
            by linarith
          rw[this]; ring
        . simp[Quaternion.mul_imJ]
          have h': (2:ℚ) * (↑k3 + (2:ℚ)⁻¹)  = ↑ya + ↑yb + ↑yc - ↑yd := by
            calc (2:ℚ) * (↑k3 + (2:ℚ)⁻¹)  = (2:ℚ) * ↑k3 + (1:ℚ) := by ring
                    _  = ↑(ya + yb + yc - yd) := by simp[hk3]
                    _  = ↑ya + ↑yb + ↑yc - ↑yd := by simp
          have ne0: (2:ℚ) ≠ 0 := by norm_num
          have : ↑k3 + (2:ℚ)⁻¹ = (2:ℚ)⁻¹ * (↑ya + ↑yb + ↑yc - ↑yd) :=
            (eq_inv_mul_iff_mul_eq₀ ne0).mpr h'
          have : ↑k3 = (2:ℚ)⁻¹ * (↑ya + ↑yb + ↑yc - ↑yd) - (2:ℚ)⁻¹:=
            by linarith
          rw[this]; ring
        . simp[Quaternion.mul_imK]
          have h': (2:ℚ) * (↑k4 + (2:ℚ)⁻¹) = ↑ya - ↑yb + ↑yc + ↑yd := by
            calc (2:ℚ) * (↑k4 + (2:ℚ)⁻¹) = (2:ℚ) * ↑k4 + (1:ℚ) := by ring
                    _  = ↑(ya - yb + yc + yd) := by simp[hk4]
                    _  = ↑ya - ↑yb + ↑yc + ↑yd := by simp
          have ne0: (2:ℚ) ≠ 0 := by norm_num
          have : ↑k4 + (2:ℚ)⁻¹= (2:ℚ)⁻¹ * (↑ya - ↑yb + ↑yc + ↑yd) :=
            (eq_inv_mul_iff_mul_eq₀ ne0).mpr h'
          have : ↑k4 = (2:ℚ)⁻¹ * (↑ya - ↑yb + ↑yc + ↑yd) - (2:ℚ)⁻¹:=
            by linarith
          rw[this]; ring
    . rcases Int.even_or_odd (xa+ya-xb-yb-xc-yc-xd-yd) with ⟨k1,hk1⟩ | ⟨k1,hk1⟩
      . use xa*ya-xb*yb-xc*yc-xd*yd+k1-1
        have ⟨k2, hk2⟩ :∃k:ℤ, xa+ya+xb+yb+xc-yc-xd+yd = k+k := by
          use k1+xb+yb+xc+yd; linarith
        use xa*yb+xb*ya+xc*yd-xd*yc+k2
        have ⟨k3, hk3⟩ :∃k:ℤ, xa+ya-xb+yb+xc+yc+xd-yd = k+k := by
          use k1+yb+xc+yc+xd; linarith
        use xa*yc-xb*yd+xc*ya+xd*yb+k3
        have ⟨k4, hk4⟩ :∃k:ℤ, xa+ya+xb-yb-xc+yc+xd+yd = k+k := by
          use k1+xb+yc+xd+yd; linarith
        use xa*yd+xb*yc-xc*yb+xd*ya+k4
        rw[hx2, hy2]; right; ext
        . simp[Quaternion.mul_re]
          have h': (2:ℚ) * ↑k1 = ↑xa + ↑ya - ↑xb - ↑yb - ↑xc - ↑yc - ↑xd - ↑yd := by
            calc (2:ℚ) * ↑k1 = ↑k1 + ↑k1 := by linarith
                    _  = ↑(k1 + k1) := by simp
                    _  = ↑(xa + ya - xb - yb - xc - yc - xd - yd) := by rw[hk1]
                    _  = ↑xa + ↑ya - ↑xb - ↑yb - ↑xc - ↑yc - ↑xd - ↑yd := by simp
          have ne0: (2:ℚ) ≠ 0 := by norm_num
          have : ↑k1 = (2:ℚ)⁻¹ * (↑xa + ↑ya - ↑xb - ↑yb - ↑xc - ↑yc - ↑xd - ↑yd) :=
            (eq_inv_mul_iff_mul_eq₀ ne0).mpr h'
          rw[this]; ring
        . simp[Quaternion.mul_imI]
          have h': (2:ℚ) * ↑k2 = ↑xa + ↑ya + ↑xb + ↑yb + ↑xc - ↑yc - ↑xd + ↑yd := by
            calc (2:ℚ) * ↑k2 = ↑k2 + ↑k2 := by linarith
                    _  = ↑(k2 + k2) := by simp
                    _  = ↑(xa + ya + xb + yb + xc - yc - xd + yd) := by rw[hk2]
                    _  = ↑xa + ↑ya + ↑xb + ↑yb + ↑xc - ↑yc - ↑xd + ↑yd := by simp
          have ne0: (2:ℚ) ≠ 0 := by norm_num
          have : ↑k2 = (2:ℚ)⁻¹ * (↑xa + ↑ya + ↑xb + ↑yb + ↑xc - ↑yc - ↑xd + ↑yd) :=
            (eq_inv_mul_iff_mul_eq₀ ne0).mpr h'
          rw[this]; ring
        . simp[Quaternion.mul_imJ]
          have h': (2:ℚ) * ↑k3 = ↑xa + ↑ya - ↑xb + ↑yb + ↑xc + ↑yc + ↑xd - ↑yd := by
            calc (2:ℚ) * ↑k3 = ↑k3 + ↑k3 := by linarith
                    _  = ↑(k3 + k3) := by simp
                    _  = ↑(xa + ya - xb + yb + xc + yc + xd - yd) := by rw[hk3]
                    _  = ↑xa + ↑ya - ↑xb + ↑yb + ↑xc + ↑yc + ↑xd - ↑yd  := by simp
          have ne0: (2:ℚ) ≠ 0 := by norm_num
          have : ↑k3 = (2:ℚ)⁻¹ * (↑xa + ↑ya - ↑xb + ↑yb + ↑xc + ↑yc + ↑xd - ↑yd) :=
            (eq_inv_mul_iff_mul_eq₀ ne0).mpr h'
          rw[this]; ring
        . simp[Quaternion.mul_imK]
          have h': (2:ℚ) * ↑k4 = ↑xa + ↑ya + ↑xb - ↑yb - ↑xc + ↑yc + ↑xd + ↑yd := by
            calc (2:ℚ) * ↑k4 = ↑k4 + ↑k4 := by linarith
                    _  = ↑(k4 + k4) := by simp
                    _  = ↑(xa + ya + xb - yb - xc + yc + xd + yd) := by rw[hk4]
                    _  = ↑xa + ↑ya + ↑xb - ↑yb - ↑xc + ↑yc + ↑xd + ↑yd := by simp
          have ne0: (2:ℚ) ≠ 0 := by norm_num
          have : ↑k4 = (2:ℚ)⁻¹ * (↑xa + ↑ya + ↑xb - ↑yb - ↑xc + ↑yc + ↑xd + ↑yd) :=
            (eq_inv_mul_iff_mul_eq₀ ne0).mpr h'
          rw[this]; ring
      . use xa*ya-xb*yb-xc*yc-xd*yd+k1
        have ⟨k2, hk2⟩ :∃k:ℤ, xa+ya+xb+yb+xc-yc-xd+yd = 2*k+1 := by
          use k1+xb+yb+xc+yd; linarith
        use xa*yb+xb*ya+xc*yd-xd*yc+k2+1
        have ⟨k3, hk3⟩ :∃k:ℤ, xa+ya-xb+yb+xc+yc+xd-yd = 2*k+1 := by
          use k1+yb+xc+yc+xd; linarith
        use xa*yc-xb*yd+xc*ya+xd*yb+k3+1
        have ⟨k4, hk4⟩ :∃k:ℤ, xa+ya+xb-yb-xc+yc+xd+yd = 2*k+1 := by
          use k1+xb+yc+xd+yd; linarith
        use xa*yd+xb*yc-xc*yb+xd*ya+k4+1
        rw[hx2, hy2]; left; ext
        . simp[Quaternion.mul_re]
          have h': (2:ℚ) * (↑k1 + (2:ℚ)⁻¹) = ↑xa + ↑ya - ↑xb - ↑yb - ↑xc - ↑yc - ↑xd - ↑yd := by
            calc (2:ℚ) * (↑k1 + (2:ℚ)⁻¹) =  (2:ℚ) * ↑k1 + (1:ℚ) := by ring
                    _  = ↑(xa + ya - xb - yb - xc - yc - xd - yd) := by simp[hk1]
                    _  = ↑xa + ↑ya - ↑xb - ↑yb - ↑xc - ↑yc - ↑xd - ↑yd := by simp
          have ne0: (2:ℚ) ≠ 0 := by norm_num
          have : ↑k1 + (2:ℚ)⁻¹ = (2:ℚ)⁻¹ * (↑xa + ↑ya - ↑xb - ↑yb - ↑xc - ↑yc - ↑xd - ↑yd) :=
            (eq_inv_mul_iff_mul_eq₀ ne0).mpr h'
          have : ↑k1 = (2:ℚ)⁻¹ * (↑xa + ↑ya - ↑xb - ↑yb - ↑xc - ↑yc - ↑xd - ↑yd) - (2:ℚ)⁻¹ :=
            by linarith
          rw[this]; ring
        . simp[Quaternion.mul_imI]
          have h': (2:ℚ) * (↑k2 + (2:ℚ)⁻¹) = ↑xa + ↑ya + ↑xb + ↑yb + ↑xc - ↑yc - ↑xd + ↑yd := by
            calc (2:ℚ) * (↑k2 + (2:ℚ)⁻¹) =  (2:ℚ) * ↑k2 + (1:ℚ) := by ring
                    _  = ↑(xa + ya + xb + yb + xc - yc - xd + yd) := by simp[hk2]
                    _  = ↑xa + ↑ya + ↑xb + ↑yb + ↑xc - ↑yc - ↑xd + ↑yd := by simp
          have ne0: (2:ℚ) ≠ 0 := by norm_num
          have : ↑k2 + (2:ℚ)⁻¹ = (2:ℚ)⁻¹ * (↑xa + ↑ya + ↑xb + ↑yb + ↑xc - ↑yc - ↑xd + ↑yd) :=
            (eq_inv_mul_iff_mul_eq₀ ne0).mpr h'
          have : ↑k2 = (2:ℚ)⁻¹ * (↑xa + ↑ya + ↑xb + ↑yb + ↑xc - ↑yc - ↑xd + ↑yd) - (2:ℚ)⁻¹ :=
            by linarith
          rw[this]; ring
        . simp[Quaternion.mul_imJ]
          have h': (2:ℚ) * (↑k3 + (2:ℚ)⁻¹) = ↑xa + ↑ya - ↑xb + ↑yb + ↑xc + ↑yc + ↑xd - ↑yd := by
            calc (2:ℚ) * (↑k3 + (2:ℚ)⁻¹) =  (2:ℚ) * ↑k3 + (1:ℚ) := by ring
                    _  = ↑(xa + ya - xb + yb + xc + yc + xd - yd) := by simp[hk3]
                    _  = ↑xa + ↑ya - ↑xb + ↑yb + ↑xc + ↑yc + ↑xd - ↑yd := by simp
          have ne0: (2:ℚ) ≠ 0 := by norm_num
          have : ↑k3 + (2:ℚ)⁻¹ = (2:ℚ)⁻¹ * (↑xa + ↑ya - ↑xb + ↑yb + ↑xc + ↑yc + ↑xd - ↑yd) :=
            (eq_inv_mul_iff_mul_eq₀ ne0).mpr h'
          have : ↑k3 = (2:ℚ)⁻¹ * (↑xa + ↑ya - ↑xb + ↑yb + ↑xc + ↑yc + ↑xd - ↑yd) - (2:ℚ)⁻¹ :=
            by linarith
          rw[this]; ring
        . simp[Quaternion.mul_imK]
          have h': (2:ℚ) * (↑k4 + (2:ℚ)⁻¹) = ↑xa + ↑ya + ↑xb - ↑yb - ↑xc + ↑yc + ↑xd + ↑yd := by
            calc (2:ℚ) * (↑k4 + (2:ℚ)⁻¹) =  (2:ℚ) * ↑k4 + (1:ℚ) := by ring
                    _  = ↑(xa + ya + xb - yb - xc + yc + xd + yd ) := by simp[hk4]
                    _  = ↑xa + ↑ya + ↑xb - ↑yb - ↑xc + ↑yc + ↑xd + ↑yd := by simp
          have ne0: (2:ℚ) ≠ 0 := by norm_num
          have : ↑k4 + (2:ℚ)⁻¹ = (2:ℚ)⁻¹ * (↑xa + ↑ya + ↑xb - ↑yb - ↑xc + ↑yc + ↑xd + ↑yd) :=
            (eq_inv_mul_iff_mul_eq₀ ne0).mpr h'
          have : ↑k4 = (2:ℚ)⁻¹ * (↑xa + ↑ya + ↑xb - ↑yb - ↑xc + ↑yc + ↑xd + ↑yd) - (2:ℚ)⁻¹ :=
            by linarith
          rw[this]; ring


/-- A lemma to show Theorem 2.1(Conditiona Four Square Theorem):
The square of the norm of a Hurwitz integer is always an integer.-/
theorem normSq_int : ∀ γ : HurInt, ∃ z : ℤ, normSq γ.val = z := by
  intro γ
  rcases half_or γ with ⟨a, b, c, d, h | h⟩
  . use a^2 + b^2 + c^2 + d^2
    simp[normSq_def', h]
  . use a^2 + b^2 + c^2 + d^2 + a + b + c + d + 1
    simp[normSq_def', h]; ring

/-- This theorem helps identify what 1 is in HurInt-/
theorem what_is_1: (@OfNat.ofNat (↥HurInt) 1 One.toOfNat1).val = ⟨1,0,0,0⟩ := by
  rfl


/-- The following 24 theorems identify the 24 units of HurInt, i.e.,
+-1, +-i, +-j, +-k, +-1/2+-i/2+-j/2+-k/2.
They are useful in proving Hurtint_unit_iff_norm_one. -/
theorem unit1000 : ∀ γ : HurInt, γ.val = ⟨1,0,0,0⟩ → IsUnit γ := by
  intro γ h
  apply isUnit_iff_exists.mpr
  use γ; simp
  ext <;> {simp; aesop}

theorem unit1000' : ∀ γ : HurInt, γ.val = ⟨-1,0,0,0⟩ → IsUnit γ := by
  intro γ h
  apply isUnit_iff_exists.mpr
  use γ; simp
  ext <;> {simp; aesop}


theorem unit0100 : ∀ γ : HurInt, γ.val = ⟨0,1,0,0⟩ → IsUnit γ := by
  intro γ h
  apply isUnit_iff_exists.mpr
  use -γ; simp
  ext <;> {simp; aesop}

theorem unit0100' : ∀ γ : HurInt, γ.val = ⟨0,-1,0,0⟩ → IsUnit γ := by
  intro γ h
  apply isUnit_iff_exists.mpr
  use -γ; simp
  ext <;> {simp; aesop}

theorem unit0010 : ∀ γ : HurInt, γ.val = ⟨0,0,1,0⟩ → IsUnit γ := by
  intro γ h
  apply isUnit_iff_exists.mpr
  use -γ; simp
  ext <;> {simp; aesop}

theorem unit0010' : ∀ γ : HurInt, γ.val = ⟨0,0,-1,0⟩ → IsUnit γ := by
  intro γ h
  apply isUnit_iff_exists.mpr
  use -γ; simp
  ext <;> {simp; aesop}

theorem unit0001 : ∀ γ : HurInt, γ.val = ⟨0,0,0,1⟩ → IsUnit γ := by
  intro γ h
  apply isUnit_iff_exists.mpr
  use -γ; simp
  ext <;> {simp; aesop}

theorem unit0001' : ∀ γ : HurInt, γ.val = ⟨0,0,0,-1⟩ → IsUnit γ := by
  intro γ h
  apply isUnit_iff_exists.mpr
  use -γ; simp
  ext <;> {simp; aesop}

theorem unit_half_pppp : ∀ γ : HurInt, γ.val = ⟨1/2, 1/2, 1/2, 1/2⟩ → IsUnit γ := by
  intro γ h
  apply isUnit_iff_exists.mpr
  use 1-γ
  constructor
  . ext <;> {simp; aesop; ring}
  . ext <;> {simp; aesop; ring}

theorem unit_half_pnnn : ∀ γ : HurInt, γ.val = ⟨1/2, -1/2, -1/2, -1/2⟩ → IsUnit γ := by
  intro γ h
  apply isUnit_iff_exists.mpr
  use 1-γ
  constructor
  . ext <;> {simp; aesop; ring}
  . ext <;> {simp; aesop; ring}

theorem unit_half_nppp : ∀ γ : HurInt, γ.val = ⟨-1/2, 1/2, 1/2, 1/2⟩ → IsUnit γ := by
  intro γ h
  apply isUnit_iff_exists.mpr
  use -1-γ
  constructor
  . ext <;> {simp; aesop; ring}
  . ext <;> {simp; aesop; ring}

theorem unit_half_nnnn : ∀ γ : HurInt, γ.val = ⟨-1/2, -1/2, -1/2, -1/2⟩ → IsUnit γ := by
  intro γ h
  apply isUnit_iff_exists.mpr
  use -1-γ
  constructor
  . ext <;> {simp; aesop; ring}
  . ext <;> {simp; aesop; ring}

theorem unit_half_pnpp : ∀ γ : HurInt, γ.val = ⟨1/2, -1/2, 1/2, 1/2⟩ → IsUnit γ := by
  intro γ h
  apply isUnit_iff_exists.mpr
  use 1-γ
  constructor
  . ext <;> {simp; aesop; ring}
  . ext <;> {simp; aesop; ring}

theorem unit_half_ppnn : ∀ γ : HurInt, γ.val = ⟨1/2, 1/2, -1/2, -1/2⟩ → IsUnit γ := by
  intro γ h
  apply isUnit_iff_exists.mpr
  use 1-γ
  constructor
  . ext <;> {simp; aesop; ring}
  . ext <;> {simp; aesop; ring}

theorem unit_half_ppnp : ∀ γ : HurInt, γ.val = ⟨1/2, 1/2, -1/2, 1/2⟩ → IsUnit γ := by
  intro γ h
  apply isUnit_iff_exists.mpr
  use 1-γ
  constructor
  . ext <;> {simp; aesop; ring}
  . ext <;> {simp; aesop; ring}

theorem unit_half_pnpn : ∀ γ : HurInt, γ.val = ⟨1/2, -1/2, 1/2, -1/2⟩ → IsUnit γ := by
  intro γ h
  apply isUnit_iff_exists.mpr
  use 1-γ
  constructor
  . ext <;> {simp; aesop; ring}
  . ext <;> {simp; aesop; ring}

theorem unit_half_pppn : ∀ γ : HurInt, γ.val = ⟨1/2, 1/2, 1/2, -1/2⟩ → IsUnit γ := by
  intro γ h
  apply isUnit_iff_exists.mpr
  use 1-γ
  constructor
  . ext <;> {simp; aesop; ring}
  . ext <;> {simp; aesop; ring}

theorem unit_half_pnnp : ∀ γ : HurInt, γ.val = ⟨1/2, -1/2, -1/2, 1/2⟩ → IsUnit γ := by
  intro γ h
  apply isUnit_iff_exists.mpr
  use 1-γ
  constructor
  . ext <;> {simp; aesop; ring}
  . ext <;> {simp; aesop; ring}

theorem unit_half_nnpp : ∀ γ : HurInt, γ.val = ⟨-1/2, -1/2, 1/2, 1/2⟩ → IsUnit γ := by
  intro γ h
  apply isUnit_iff_exists.mpr
  use -1-γ
  constructor
  . ext <;> {simp; aesop; ring}
  . ext <;> {simp; aesop; ring}

theorem unit_half_npnn : ∀ γ : HurInt, γ.val = ⟨-1/2, 1/2, -1/2, -1/2⟩ → IsUnit γ := by
  intro γ h
  apply isUnit_iff_exists.mpr
  use -1-γ
  constructor
  . ext <;> {simp; aesop; ring}
  . ext <;> {simp; aesop; ring}

theorem unit_half_npnp : ∀ γ : HurInt, γ.val = ⟨-1/2, 1/2, -1/2, 1/2⟩ → IsUnit γ := by
  intro γ h
  apply isUnit_iff_exists.mpr
  use -1-γ
  constructor
  . ext <;> {simp; aesop; ring}
  . ext <;> {simp; aesop; ring}

theorem unit_half_nnpn : ∀ γ : HurInt, γ.val = ⟨-1/2, -1/2, 1/2, -1/2⟩ → IsUnit γ := by
  intro γ h
  apply isUnit_iff_exists.mpr
  use -1-γ
  constructor
  . ext <;> {simp; aesop; ring}
  . ext <;> {simp; aesop; ring}

theorem unit_half_nppn : ∀ γ : HurInt, γ.val = ⟨-1/2, 1/2, 1/2, -1/2⟩ → IsUnit γ := by
  intro γ h
  apply isUnit_iff_exists.mpr
  use -1-γ
  constructor
  . ext <;> {simp; aesop; ring}
  . ext <;> {simp; aesop; ring}

theorem unit_half_nnnp : ∀ γ : HurInt, γ.val = ⟨-1/2, -1/2, -1/2, 1/2⟩ → IsUnit γ := by
  intro γ h
  apply isUnit_iff_exists.mpr
  use -1-γ
  constructor
  . ext <;> {simp; aesop; ring}
  . ext <;> {simp; aesop; ring}


/-- A lemma that helps us prove Hurtint_unit_iff_norm_one-/
theorem foo : ∀ a : ℤ , (-3/2:ℚ) ≤ ↑a ∧ ↑a ≤ (1/2:ℚ)→ (↑a+1/2) * (↑a+1/2) ≤ (1: ℚ)→
a = -1 ∨ a = 0 := by
  intro a ha _
  refine CovBy.eq_or_eq ?h ?h2 ?h3
  . exact Int.covBy_iff_succ_eq.mpr rfl
  . refine (Mathlib.Tactic.Qify.intCast_le (-1) a).mpr ?h2.a
    by_contra h
    simp at h
    have hn1:a < -1 := by exact (Mathlib.Tactic.Qify.intCast_lt a (-1)).mpr h
    have : a ≤ -2 := by linarith
    have : ↑a ≤ (-2:ℚ) := by exact Rat.le_floor.mp this
    have : (↑a + 1/2) * (↑a + 1/2) > 1 := by linarith
    have : 1 < 1 := by linarith
    contradiction
  . refine (Mathlib.Tactic.Qify.intCast_le a 0).mpr ?h3.a
    by_contra h
    simp at h
    have hp1: a ≥ 1 := h
    have : ↑a ≥ (1:ℚ) := by exact Rat.le_floor.mp hp1
    have : (↑a + 1/2) * (↑a + 1/2) > 1 := by linarith
    have : 1 < 1 := by linarith
    contradiction

/--This helps us prove Hurtint_unit_of_int_unit. -/
theorem Hurtint_unit_iff_norm_one: ∀ γ : HurInt, IsUnit γ ↔ normSq γ.val = 1 := by
  intro γ
  constructor
  . intro h
    rcases (isUnit_iff_exists.mp h) with ⟨b, hbl, hbr⟩
    have h1: normSq (γ * b).val = 1 := by simp[hbl]
    have h2: normSq (γ * b).val = normSq γ.val * normSq b.val := by simp[normSq]
    have h3 : normSq γ.val * normSq b.val = 1 := by aesop
    have ⟨z,hz⟩ := normSq_int γ
    have ⟨w,hw⟩ := normSq_int b
    simp[hz,hw] at h3; simp[hz]
    have hzge : (0: ℚ) ≤ ↑z:= by rw[← hz]; apply normSq_nonneg
    have hwge : (0: ℚ) ≤ ↑w:= by rw[← hw]; apply normSq_nonneg
    rcases (lt_or_le 0 z) with hz0 | hz0
    . have hz1: 1 ≤ z := Int.pos_iff_one_le.mp hz0
      have hwg : 0 < w := by
        rcases (lt_or_le 0 w) with hw0 | hw0
        . exact hw0
        . have : ↑w ≤ (0: ℚ) := by simp[hw0]
          have : ↑w = (0: ℚ) := by linarith
          rw[this] at h3; by_contra; linarith
      have hw1: 1 ≤ w := Int.pos_iff_one_le.mp hwg
      rcases (le_iff_eq_or_lt.mp hz1) with hz1l|hz1e
      . exact Eq.symm hz1l
      . have h01 : (0:ℤ) < (1:ℤ) := by linarith
        have : (0:ℤ) ≤ z := by omega
        have hzw: 1 < z * w := by apply Int.mul_lt_mul hz1e hw1 h01 this
        have zwlift: (↑(z * w) : ℚ) = (↑z * ↑w : ℚ) := by simp
        have : (1:ℚ) < ↑(z * w):= Int.floor_lt.mp hzw
        have : (1:ℚ) < ↑z * ↑w := by apply lt_of_lt_of_eq this zwlift
        rw[h3] at this; contradiction
    . have : ↑z ≤ (0: ℚ) := by simp[hz0]
      have : ↑z = (0: ℚ) := by linarith
      rw[this] at h3; by_contra; linarith
  . intro h
    simp[normSq] at *
    rcases half_or γ with ⟨a, b, c, d, h1|h1⟩
    . have ha: (@Subtype.val ℍ[ℚ] (fun x => x ∈ HurInt) γ).re = ↑a := by aesop
      have hb: (@Subtype.val ℍ[ℚ] (fun x => x ∈ HurInt) γ).imI = ↑b := by aesop
      have hc: (@Subtype.val ℍ[ℚ] (fun x => x ∈ HurInt) γ).imJ = ↑c := by aesop
      have hd: (@Subtype.val ℍ[ℚ] (fun x => x ∈ HurInt) γ).imK = ↑d := by aesop
      rw[ha,hb,hc,hd] at h
      have ha0 : (0: ℚ) ≤ ↑a * ↑a := mul_self_nonneg ↑a
      have hb0 : (0: ℚ) ≤ ↑b * ↑b := mul_self_nonneg ↑b
      have hc0 : (0: ℚ) ≤ ↑c * ↑c := mul_self_nonneg ↑c
      have hd0 : (0: ℚ) ≤ ↑d * ↑d := mul_self_nonneg ↑d
      have ha1 : ↑(a * a) ≤ (1: ℚ):= by calc
        ↑(a * a) = ↑a * ↑a := by simp
               _ ≤ (1: ℚ) := by linarith
      have hb1 : ↑(b * b) ≤ (1: ℚ):= by calc
        ↑(b * b) = ↑b * ↑b := by simp
               _ ≤ (1: ℚ) := by linarith
      have hc1 : ↑(c * c) ≤ (1: ℚ):= by calc
        ↑(c * c) = ↑c * ↑c := by simp
               _ ≤ (1: ℚ) := by linarith
      have hd1 : ↑(d * d) ≤ (1: ℚ):= by calc
        ↑(d * d) = ↑d * ↑d := by simp
               _ ≤ (1: ℚ) := by linarith
      have ha0z : 0 ≤ a * a := mul_self_nonneg a
      have hb0z : 0 ≤ b * b := mul_self_nonneg b
      have hc0z : 0 ≤ c * c := mul_self_nonneg c
      have hd0z : 0 ≤ d * d := mul_self_nonneg d
      have ha1z : a * a ≤ 1:= by apply Int.le_floor.mpr ha1
      have hb1z : b * b ≤ 1:= by apply Int.le_floor.mpr hb1
      have hc1z : c * c ≤ 1:= by apply Int.le_floor.mpr hc1
      have hd1z : d * d ≤ 1:= by apply Int.le_floor.mpr hd1
      have ha01 : a * a = 0 ∨ a * a = 1 := by omega
      have hb01 : b * b = 0 ∨ b * b = 1 := by omega
      have hc01 : c * c = 0 ∨ c * c = 1 := by omega
      have hd01 : d * d = 0 ∨ d * d = 1 := by omega
      rcases ha01 with hae0 | hae1
      . rcases hb01 with hbe0 | hbe1 --hae0
        . rcases hc01 with hce0 | hce1 --hbe0
          . rcases hd01 with hde0 | hde1 --hce0
            have ha0': a = 0 := zero_eq_mul_self.mp (id hae0.symm)
            have hb0': b = 0 := zero_eq_mul_self.mp (id hbe0.symm)
            have hc0': c = 0 := zero_eq_mul_self.mp (id hce0.symm)
            . have : a * a + b * b + c * c + d * d = 0 := by linarith
              have hsum0: ↑a * ↑a + ↑b * ↑b + ↑c * ↑c + ↑d * ↑d = (0:ℚ) := by calc
                ↑a*↑a+↑b*↑b+↑c*↑c+↑d*↑d = ↑(a*a)+↑(b*b)+↑(c*c)+↑(d*d) := by simp
                                      _ = ↑(a * a + b * b + c * c + d * d) := by simp
                                      _ = (0:ℚ) := by simp[this]
              rw[hsum0] at h
              by_contra; linarith
            . rcases (Int.eq_one_or_neg_one_of_mul_eq_one hde1) with hp1 | hn1
              . apply unit0001 γ; ext <;> {aesop}
              . apply unit0001' γ; ext <;> {aesop}
          . rcases hd01 with hde0 | hde1 --hce0
            have ha0': a = 0 := zero_eq_mul_self.mp (id hae0.symm)
            have hb0': b = 0 := zero_eq_mul_self.mp (id hbe0.symm)
            have hd0': d = 0 := zero_eq_mul_self.mp (id hde0.symm)
            . rcases (Int.eq_one_or_neg_one_of_mul_eq_one hce1) with hp1 | hn1
              . apply unit0010 γ; ext <;> {aesop}
              . apply unit0010' γ; ext <;> {aesop}
            . have : a * a + b * b + c * c + d * d = 2 := by linarith
              have hsum0: ↑a * ↑a + ↑b * ↑b + ↑c * ↑c + ↑d * ↑d = (2:ℚ) := by calc
                ↑a*↑a+↑b*↑b+↑c*↑c+↑d*↑d = ↑(a*a)+↑(b*b)+↑(c*c)+↑(d*d) := by simp
                                      _ = ↑(a * a + b * b + c * c + d * d) := by simp
                                      _ = (2:ℚ) := by simp[this]
              rw[hsum0] at h
              by_contra; linarith
        . rcases hc01 with hce0 | hce1  --hbe1
          . rcases hd01 with hde0 | hde1 --hce0
            have ha0': a = 0 := zero_eq_mul_self.mp (id hae0.symm)
            have hc0': c = 0 := zero_eq_mul_self.mp (id hce0.symm)
            have hd0': d = 0 := zero_eq_mul_self.mp (id hde0.symm)
            . rcases (Int.eq_one_or_neg_one_of_mul_eq_one hbe1) with hp1 | hn1
              . apply unit0100 γ; ext <;> {aesop}
              . apply unit0100' γ; ext <;> {aesop}
            . have : a * a + b * b + c * c + d * d = 2 := by linarith
              have hsum0: ↑a * ↑a + ↑b * ↑b + ↑c * ↑c + ↑d * ↑d = (2:ℚ) := by calc
                ↑a*↑a+↑b*↑b+↑c*↑c+↑d*↑d = ↑(a*a)+↑(b*b)+↑(c*c)+↑(d*d) := by simp
                                      _ = ↑(a * a + b * b + c * c + d * d) := by simp
                                      _ = (2:ℚ) := by simp[this]
              rw[hsum0] at h
              by_contra; linarith
          . rcases hd01 with hde0 | hde1 --hce1
            . have : a * a + b * b + c * c + d * d = 2 := by linarith
              have hsum0: ↑a * ↑a + ↑b * ↑b + ↑c * ↑c + ↑d * ↑d = (2:ℚ) := by calc
                ↑a*↑a+↑b*↑b+↑c*↑c+↑d*↑d = ↑(a*a)+↑(b*b)+↑(c*c)+↑(d*d) := by simp
                                      _ = ↑(a * a + b * b + c * c + d * d) := by simp
                                      _ = (2:ℚ) := by simp[this]
              rw[hsum0] at h
              by_contra; linarith
            . have : a * a + b * b + c * c + d * d = 3 := by linarith
              have hsum0: ↑a * ↑a + ↑b * ↑b + ↑c * ↑c + ↑d * ↑d = (3:ℚ) := by calc
                ↑a*↑a+↑b*↑b+↑c*↑c+↑d*↑d = ↑(a*a)+↑(b*b)+↑(c*c)+↑(d*d) := by simp
                                      _ = ↑(a * a + b * b + c * c + d * d) := by simp
                                      _ = (3:ℚ) := by simp[this]
              rw[hsum0] at h
              by_contra; linarith
      . rcases hb01 with hbe0 | hbe1 --hae1
        . rcases hc01 with hce0 | hce1 --hbe0
          . rcases hd01 with hde0 | hde1 --hce0
            . rcases (Int.eq_one_or_neg_one_of_mul_eq_one hae1) with hp1 | hn1
              . apply unit1000 γ; ext <;> {aesop}
              . apply unit1000' γ; ext <;> {aesop}
            . have : a * a + b * b + c * c + d * d = 2 := by linarith
              have hsum0: ↑a * ↑a + ↑b * ↑b + ↑c * ↑c + ↑d * ↑d = (2:ℚ) := by calc
                ↑a*↑a+↑b*↑b+↑c*↑c+↑d*↑d = ↑(a*a)+↑(b*b)+↑(c*c)+↑(d*d) := by simp
                                      _ = ↑(a * a + b * b + c * c + d * d) := by simp
                                      _ = (2:ℚ) := by simp[this]
              rw[hsum0] at h
              by_contra; linarith
          . rcases hd01 with hde0 | hde1 --hce1
            . have : a * a + b * b + c * c + d * d = 2 := by linarith
              have hsum0: ↑a * ↑a + ↑b * ↑b + ↑c * ↑c + ↑d * ↑d = (2:ℚ) := by calc
                ↑a*↑a+↑b*↑b+↑c*↑c+↑d*↑d = ↑(a*a)+↑(b*b)+↑(c*c)+↑(d*d) := by simp
                                      _ = ↑(a * a + b * b + c * c + d * d) := by simp
                                      _ = (2:ℚ) := by simp[this]
              rw[hsum0] at h
              by_contra; linarith
            . have : a * a + b * b + c * c + d * d = 3 := by linarith
              have hsum0: ↑a * ↑a + ↑b * ↑b + ↑c * ↑c + ↑d * ↑d = (3:ℚ) := by calc
                ↑a*↑a+↑b*↑b+↑c*↑c+↑d*↑d = ↑(a*a)+↑(b*b)+↑(c*c)+↑(d*d) := by simp
                                      _ = ↑(a * a + b * b + c * c + d * d) := by simp
                                      _ = (3:ℚ) := by simp[this]
              rw[hsum0] at h
              by_contra; linarith
        . rcases hc01 with hce0 | hce1 --hbe1
          . rcases hd01 with hde0 | hde1 --hce0
            . have : a * a + b * b + c * c + d * d = 2 := by linarith
              have hsum0: ↑a * ↑a + ↑b * ↑b + ↑c * ↑c + ↑d * ↑d = (2:ℚ) := by calc
                ↑a*↑a+↑b*↑b+↑c*↑c+↑d*↑d = ↑(a*a)+↑(b*b)+↑(c*c)+↑(d*d) := by simp
                                      _ = ↑(a * a + b * b + c * c + d * d) := by simp
                                      _ = (2:ℚ) := by simp[this]
              rw[hsum0] at h
              by_contra; linarith
            . have : a * a + b * b + c * c + d * d = 3 := by linarith
              have hsum0: ↑a * ↑a + ↑b * ↑b + ↑c * ↑c + ↑d * ↑d = (3:ℚ) := by calc
                ↑a*↑a+↑b*↑b+↑c*↑c+↑d*↑d = ↑(a*a)+↑(b*b)+↑(c*c)+↑(d*d) := by simp
                                      _ = ↑(a * a + b * b + c * c + d * d) := by simp
                                      _ = (3:ℚ) := by simp[this]
              rw[hsum0] at h
              by_contra; linarith
          . rcases hd01 with hde0 | hde1 --hce1
            . have : a * a + b * b + c * c + d * d = 3 := by linarith
              have hsum0: ↑a * ↑a + ↑b * ↑b + ↑c * ↑c + ↑d * ↑d = (3:ℚ) := by calc
                ↑a*↑a+↑b*↑b+↑c*↑c+↑d*↑d = ↑(a*a)+↑(b*b)+↑(c*c)+↑(d*d) := by simp
                                      _ = ↑(a * a + b * b + c * c + d * d) := by simp
                                      _ = (3:ℚ) := by simp[this]
              rw[hsum0] at h
              by_contra; linarith
            . have : a * a + b * b + c * c + d * d = 4 := by linarith
              have hsum0: ↑a * ↑a + ↑b * ↑b + ↑c * ↑c + ↑d * ↑d = (4:ℚ) := by calc
                ↑a*↑a+↑b*↑b+↑c*↑c+↑d*↑d = ↑(a*a)+↑(b*b)+↑(c*c)+↑(d*d) := by simp
                                      _ = ↑(a * a + b * b + c * c + d * d) := by simp
                                      _ = (4:ℚ) := by simp[this]
              rw[hsum0] at h
              by_contra; linarith
    . have ha: (@Subtype.val ℍ[ℚ] (fun x => x ∈ HurInt) γ).re = ↑a + 1/2 := by aesop
      have hb: (@Subtype.val ℍ[ℚ] (fun x => x ∈ HurInt) γ).imI = ↑b + 1/2 := by aesop
      have hc: (@Subtype.val ℍ[ℚ] (fun x => x ∈ HurInt) γ).imJ = ↑c + 1/2 := by aesop
      have hd: (@Subtype.val ℍ[ℚ] (fun x => x ∈ HurInt) γ).imK = ↑d + 1/2 := by aesop
      rw[ha,hb,hc,hd] at h
      have ha0 : (0: ℚ) ≤ (↑a+1/2) * (↑a+1/2) := mul_self_nonneg (↑a+(1/2:ℚ))
      have hb0 : (0: ℚ) ≤ (↑b+1/2) * (↑b+1/2) := mul_self_nonneg (↑b+(1/2:ℚ))
      have hc0 : (0: ℚ) ≤ (↑c+1/2) * (↑c+1/2) := mul_self_nonneg (↑c+(1/2:ℚ))
      have hd0 : (0: ℚ) ≤ (↑d+1/2) * (↑d+1/2) := mul_self_nonneg (↑d+(1/2:ℚ))
      have ha1 : (↑a+1/2) * (↑a+1/2) ≤ (1: ℚ):= by linarith
      have hb1 : (↑b+1/2) * (↑b+1/2) ≤ (1: ℚ):= by linarith
      have hc1 : (↑c+1/2) * (↑c+1/2) ≤ (1: ℚ):= by linarith
      have hd1 : (↑d+1/2) * (↑d+1/2) ≤ (1: ℚ):= by linarith
      have hah : (-3/2:ℚ) ≤ ↑a ∧ ↑a ≤ (1/2:ℚ) := by
        have := by calc
          (↑a+1/2)^2 = (↑a+1/2) * (↑a+1/2) := by ring
                  _  ≤ (1: ℚ) := ha1
                  _  = (1: ℚ)^2 := by linarith
        have := by calc
          |↑a+(1:ℚ)/(2:ℚ)| ≤ |(1:ℚ)| := by exact sq_le_sq.mp this
                _  = (1:ℚ) := by simp
        have : (-1: ℚ) ≤ ↑a+1/2 ∧ ↑a+1/2 ≤ (1: ℚ) := by exact abs_le.mp this
        constructor
        . have : (-3:ℚ)/(2:ℚ) = (-1:ℚ)/(2:ℚ)-(1:ℚ) := by norm_num
          linarith
        . have : (1:ℚ)/(2:ℚ) = (1:ℚ)-(1:ℚ)/(2:ℚ) := by norm_num
          linarith
      have hbh : (-3/2:ℚ) ≤ ↑b ∧ ↑b ≤ (1/2:ℚ) := by
        have := by calc
          (↑b+1/2)^2 = (↑b+1/2) * (↑b+1/2) := by ring
                  _  ≤ (1: ℚ) := hb1
                  _  = (1: ℚ)^2 := by linarith
        have := by calc
          |↑b+(1:ℚ)/(2:ℚ)| ≤ |(1:ℚ)| := by exact sq_le_sq.mp this
                _  = (1:ℚ) := by simp
        have : (-1: ℚ) ≤ ↑b+1/2 ∧ ↑b+1/2 ≤ (1: ℚ) := by exact abs_le.mp this
        constructor
        . have : (-3:ℚ)/(2:ℚ) = (-1:ℚ)/(2:ℚ)-(1:ℚ) := by norm_num
          linarith
        . have : (1:ℚ)/(2:ℚ) = (1:ℚ)-(1:ℚ)/(2:ℚ) := by norm_num
          linarith
      have hch : (-3/2:ℚ) ≤ ↑c ∧ ↑c ≤ (1/2:ℚ) := by
        have := by calc
          (↑c+1/2)^2 = (↑c+1/2) * (↑c+1/2) := by ring
                  _  ≤ (1: ℚ) := hc1
                  _  = (1: ℚ)^2 := by linarith
        have := by calc
          |↑c+(1:ℚ)/(2:ℚ)| ≤ |(1:ℚ)| := by exact sq_le_sq.mp this
                _  = (1:ℚ) := by simp
        have : (-1: ℚ) ≤ ↑c+1/2 ∧ ↑c+1/2 ≤ (1: ℚ) := by exact abs_le.mp this
        constructor
        . have : (-3:ℚ)/(2:ℚ) = (-1:ℚ)/(2:ℚ)-(1:ℚ) := by norm_num
          linarith
        . have : (1:ℚ)/(2:ℚ) = (1:ℚ)-(1:ℚ)/(2:ℚ) := by norm_num
          linarith
      have hdh : (-3/2:ℚ) ≤ ↑d ∧ ↑d ≤ (1/2:ℚ) := by
        have := by calc
          (↑d+1/2)^2 = (↑d+1/2) * (↑d+1/2) := by ring
                  _  ≤ (1: ℚ) := hd1
                  _  = (1: ℚ)^2 := by linarith
        have := by calc
          |↑d+(1:ℚ)/(2:ℚ)| ≤ |(1:ℚ)| := by exact sq_le_sq.mp this
                _  = (1:ℚ) := by simp
        have : (-1: ℚ) ≤ ↑d+1/2 ∧ ↑d+1/2 ≤ (1: ℚ) := by exact abs_le.mp this
        constructor
        . have : (-3:ℚ)/(2:ℚ) = (-1:ℚ)/(2:ℚ)-(1:ℚ) := by norm_num
          linarith
        . have : (1:ℚ)/(2:ℚ) = (1:ℚ)-(1:ℚ)/(2:ℚ) := by norm_num
          linarith
      have ha10 := foo a hah ha1
      have hb10 := foo b hbh hb1
      have hc10 := foo c hch hc1
      have hd10 := foo d hdh hd1
      rcases ha10 with ha1 | ha0
      . rcases hb10 with hb1 | hb0
        . rcases hc10 with hc1 | hc0
          . rcases hd10 with hd1 | hd0
            . apply unit_half_nnnn γ; ext
              . simp; rw[ha, ha1]; simp; norm_num
              . simp; rw[hb, hb1]; simp; norm_num
              . simp; rw[hc, hc1]; simp; norm_num
              . simp; rw[hd, hd1]; simp; norm_num
            . apply unit_half_nnnp γ; ext
              . simp; rw[ha, ha1]; simp; norm_num
              . simp; rw[hb, hb1]; simp; norm_num
              . simp; rw[hc, hc1]; simp; norm_num
              . simp; rw[hd, hd0]; simp
          . rcases hd10 with hd1 | hd0
            . apply unit_half_nnpn γ; ext
              . simp; rw[ha, ha1]; simp; norm_num
              . simp; rw[hb, hb1]; simp; norm_num
              . simp; rw[hc, hc0]; simp
              . simp; rw[hd, hd1]; simp; norm_num
            . apply unit_half_nnpp γ; ext
              . simp; rw[ha, ha1]; simp; norm_num
              . simp; rw[hb, hb1]; simp; norm_num
              . simp; rw[hc, hc0]; simp
              . simp; rw[hd, hd0]; simp
        . rcases hc10 with hc1 | hc0
          . rcases hd10 with hd1 | hd0
            . apply unit_half_npnn γ; ext
              . simp; rw[ha, ha1]; simp; norm_num
              . simp; rw[hb, hb0]; simp
              . simp; rw[hc, hc1]; simp; norm_num
              . simp; rw[hd, hd1]; simp; norm_num
            . apply unit_half_npnp γ; ext
              . simp; rw[ha, ha1]; simp; norm_num
              . simp; rw[hb, hb0]; simp
              . simp; rw[hc, hc1]; simp; norm_num
              . simp; rw[hd, hd0]; simp
          . rcases hd10 with hd1 | hd0
            . apply unit_half_nppn γ; ext
              . simp; rw[ha, ha1]; simp; norm_num
              . simp; rw[hb, hb0]; simp;
              . simp; rw[hc, hc0]; simp
              . simp; rw[hd, hd1]; simp; norm_num
            . apply unit_half_nppp γ; ext
              . simp; rw[ha, ha1]; simp; norm_num
              . simp; rw[hb, hb0]; simp
              . simp; rw[hc, hc0]; simp
              . simp; rw[hd, hd0]; simp
      . rcases hb10 with hb1 | hb0
        . rcases hc10 with hc1 | hc0
          . rcases hd10 with hd1 | hd0
            . apply unit_half_pnnn γ; ext
              . simp; rw[ha, ha0]; simp
              . simp; rw[hb, hb1]; simp; norm_num
              . simp; rw[hc, hc1]; simp; norm_num
              . simp; rw[hd, hd1]; simp; norm_num
            . apply unit_half_pnnp γ; ext
              . simp; rw[ha, ha0]; simp
              . simp; rw[hb, hb1]; simp; norm_num
              . simp; rw[hc, hc1]; simp; norm_num
              . simp; rw[hd, hd0]; simp
          . rcases hd10 with hd1 | hd0
            . apply unit_half_pnpn γ; ext
              . simp; rw[ha, ha0]; simp
              . simp; rw[hb, hb1]; simp; norm_num
              . simp; rw[hc, hc0]; simp
              . simp; rw[hd, hd1]; simp; norm_num
            . apply unit_half_pnpp γ; ext
              . simp; rw[ha, ha0]; simp
              . simp; rw[hb, hb1]; simp; norm_num
              . simp; rw[hc, hc0]; simp
              . simp; rw[hd, hd0]; simp
        . rcases hc10 with hc1 | hc0
          . rcases hd10 with hd1 | hd0
            . apply unit_half_ppnn γ; ext
              . simp; rw[ha, ha0]; simp
              . simp; rw[hb, hb0]; simp
              . simp; rw[hc, hc1]; simp; norm_num
              . simp; rw[hd, hd1]; simp; norm_num
            . apply unit_half_ppnp γ; ext
              . simp; rw[ha, ha0]; simp
              . simp; rw[hb, hb0]; simp
              . simp; rw[hc, hc1]; simp; norm_num
              . simp; rw[hd, hd0]; simp
          . rcases hd10 with hd1 | hd0
            . apply unit_half_pppn γ; ext
              . simp; rw[ha, ha0]; simp
              . simp; rw[hb, hb0]; simp
              . simp; rw[hc, hc0]; simp
              . simp; rw[hd, hd1]; simp; norm_num
            . apply unit_half_pppp γ; ext
              . simp; rw[ha, ha0]; simp
              . simp; rw[hb, hb0]; simp
              . simp; rw[hc, hc0]; simp
              . simp; rw[hd, hd0]; simp

/-- A lemma to show Theorem 2.1(Conditiona Four Square Theorem)-/
theorem Hurtint_unit_of_int_unit : ∀ γ : HurInt, ∀ z : ℤ, normSq γ.val = z → IsUnit z → IsUnit γ
  := by
  intro γ z hγ hz
  have : z = 1 := by
    rcases (Int.isUnit_eq_one_or hz) with h | h
    . exact h
    . rw[h] at hγ
      have : (normSq ↑γ) ≥ (0 :ℚ) := normSq_nonneg
      rw[hγ] at this
      contradiction
  apply (Hurtint_unit_iff_norm_one γ).mpr
  rw[hγ]
  simp[this]


/-- A theorem stating that Hurwitz integers have left euclidean division-/
theorem left_euclidean_division : ∀ α β : HurInt, β ≠ 0 → ∃ μ ρ : HurInt,
      α.val = μ.val * β.val + ρ.val ∧ normSq ρ.val  < normSq β.val:= by
      sorry

/-- A theorem stating that Hurwitz integers have right euclidean division-/
theorem right_euclidean_division : ∀ α β : HurInt, β ≠ 0 →∃ μ ρ : HurInt,
      α.val = β.val * μ.val + ρ.val ∧ normSq ρ.val  < normSq β.val:= by sorry
